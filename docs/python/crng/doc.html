<HTML>
<HEAD>
<TITLE>
crng: RNGs as Python extension types coded in C
</TITLE>
</HEAD>
<BODY BGCOLOR="WHITE">

<H1 ALIGN="CENTER">crng</H1>

<H1 ALIGN="CENTER">
Random-number generators (RNGs) implemented as Python extension types
coded in C.
</H2> 

<H2 ALIGN="CENTER">version 1.2 (released 23 Oct 2002)</H2>

<H2 ALIGN="CENTER">Per Kraulis</H2>

<P>
<TABLE>
<TR>

<TD>
<UL>
<LI><A HREF="#Copyright">Copyright notice</A>
<LI><A HREF="#Website">Official web site</A>
<LI><A HREF="#Introduction">Introduction</A>
<LI><A HREF="#Installation">Installation</A>
<LI><A HREF="#Usage">Usage</A>
<LI><A HREF="#Methods">Methods available for all RNG objects</A>
<LI><A HREF="#Saving">Saving and restoring an RNG object</A>
<LI><A HREF="#C interface">C interface</A>
<LI><A HREF="#Scripts">Scripts</A>
  <UL>
  <LI><A HREF="#validate.py">validate.py</A>
  <LI><A HREF="#profile.py">profile.py</A>
  <LI><A HREF="#display.py">display.py</A>
  <LI><A HREF="#crng_pickle.py">crng_pickle.py</A>
  </UL>
<LI><A HREF="#Profiling">Profiling (CPU timings)</A>
<LI><A HREF="#Changes 1.2">Changes in version 1.2</A>
<LI><A HREF="#Changes 1.1">Changes in version 1.1</A>
<LI><A HREF="#To do">To do</A>
<LI><A HREF="#References">References</A>
<LI><A HREF="#Acknowledgments">Acknowledgments</A>
</UL>
</TD>

<TD>
<UL>
<LI><A HREF="#Basic">Basic RNGs: uniform (0,1) distribution</A>
  <UL>
  <LI><A HREF="#ParkMiller">ParkMiller</A>
  <LI><A HREF="#WichmannHill">WichmannHill</A>
  <LI><A HREF="#LEcuyer">LEcuyer</A>
  <LI><A HREF="#Ranlux">Ranlux</A>
  <LI><A HREF="#Taus88">Taus88</A>
  <LI><A HREF="#MRG32k3a">MRG32k3a</A>
  <LI><A HREF="#MT19937">MT19937</A>
  </UL>
<LI><A HREF="#continuous">Deviates of continuous distributions</A>
  <UL>
  <LI><A HREF="#UniformDeviate">UniformDeviate</A>
  <LI><A HREF="#ExponentialDeviate">ExponentialDeviate</A>
  <LI><A HREF="#NormalDeviate">NormalDeviate</A>
  <LI><A HREF="#GammaDeviate">GammaDeviate</A>
  <LI><A HREF="#BetaDeviate">BetaDeviate</A>
  </UL>
<LI><A HREF="#integer">Deviates of integer-valued distributions</A>
  <UL>
  <LI><A HREF="#PoissonDeviate">PoissonDeviate</A>
  <LI><A HREF="#BinomialDeviate">BinomialDeviate</A>
  <LI><A HREF="#GeometricDeviate">GeometricDeviate</A>
  <LI><A HREF="#BernoulliDeviate">BernoulliDeviate</A>
  </UL>
<LI><A HREF="#Sampling">Sampling and shuffling</A>
  <UL>
  <LI><A HREF="#choose">choose</A>
  <LI><A HREF="#sample">sample</A>
  <LI><A HREF="#shuffle">shuffle</A>
  <LI><A HREF="#stir">stir</A>
  <LI><A HREF="#pick">pick</A>
  </UL>
</UL>
</TD>

</TR>
</TABLE>
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Copyright">Copyright notice</A></H2>

<P ALIGN="CENTER">
<STRONG>Copyright &copy; 2000-2002 Per Kraulis</STRONG>
</P>

<STRONG>

<P>
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
</P>
<P>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License (file <A HREF="gpl.txt">gpl.txt</A>) for
more details.
</P>
<P>
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
</P>

</STRONG>

<P>
The <A HREF="#MT19937">MT19937</A> code has been copyrighted by
Matsumoto & Nishimura, (see the copyright notice in that section), and
is governed by the GNU Lesser General Public License (LGPL, file <A
HREF="lgpl.txt">lgpl.txt</A>,  previously called 'GNU Library General
Public License').
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Website">Official website</A></H2>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Introduction">Introduction</A></H2>

<P>
The <A HREF="http://www.python.org/">Python</A> module
<STRONG>crng</STRONG> implements random-number generators (RNGs) based
on several different algorithms producing uniform deviates in the open
interval (0,1), i.e. exclusive of the end-point values 0 and 1. A few
continuous and integer-valued non-uniform deviates are also
available. Each RNG algorithm is implemented as a separate Python 
extension type. The RNG types are independent of each other, but have
very similar interfaces. The entire module is implemented as one
single C source code file.
</P>
<P>
There are already several RNGs available for Python, notably the
standard module <STRONG>random</STRONG> (implementing various
random-number distributions) based on <STRONG>whrandom</STRONG> (the
Wichmann-Hill algorithm). These are coded in Python, and hence
slow. The purpose of the <STRONG>crng</STRONG> module is to provide
efficient implementations coded in C of several modern RNG
algorithms. The design allows easy comparison and interchange of the
RNGs in Python code.
</P>
<P>
The <STRONG>crng</STRONG> module contains a
<A HREF="#C interface">C interface</A> that allows other Python
extension modules to directly call the C function for each RNG
implementation. One may thereby attain execution speeds close to those
possible for a direct implementation in C, while retaining the
flexibility of the Python interface.
</P>
<P>
Several recent and reasonably well-tested RNGs are available in this
module. This author is by no means an expert on the subject, but
having read some of the recent literature, I would recommend using 
<A HREF="#MT19937">MT19937</A>; it appears to combine speed of
execution with good results in several standard tests of RNG
quality. It has an astronomical period of approximately
4.3*10<SUP>6001</SUP>.
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Installation">Installation</A></H2>

<P>
The source code for the <STRONG>crng</STRONG> module consists of one
and only one C code file <STRONG>crng.c</STRONG>, which is made
available to the Python system by compiling it into a shared-object
file or DLL, and placing it in an appropriate directory in the Python
search path. The script file <STRONG>crng_pickle.py</STRONG> should be
installed in the same directory, if it is needed.
</P>
<P>
The module has been tested with Python 1.5.2, and reportedly works
with Python 2.0 also. Modifications have been made to the C source
code to allow direct compilation using common Windows compilers.
</P>
<P>
Shared-object files for a few specific systems are available for
direct download from <A HREF="#Website">the official web
site</A>. Otherwise, you must compile it yourself from the source code
distribution.
</P>

<H3>Unpacking the distribution</H3>

<P>
The distribution is a gzipped tar file. To unpack it, do:
</P>

<PRE>
    gunzip crng-1.2.tar.gz
    tar xvf crng-1.2.tar
    cd crng-1.2
</PRE>

<P>
The files can also be downloaded one by one from <A
HREF="#Website">the official web site</A>. 
</P>

<H3>Using setup.py with Distutils</H3>

<P>
If you have Distutils installed, you can use the
<STRONG>setup.py</STRONG> script to perform the installation. Refer to
the Distutils documentation.
</P>

<H3>Using old-style installation on Unix</H3>

<P>
If you do not have Distutils installed, you must use the old-style
installation procedure. The following information is for Unix
(including Linux) systems. The author has no experience with software
development on Windows systems, so there is currently no information
for Windows.
</P>

<P>
Fetch a copy of the file <STRONG>Makefile.pre.in</STRONG> to the
current directory. Common locations for this file are the directories 
<STRONG>/usr/lib/python2.1/config/</STRONG> or
<STRONG>/usr/local/lib/python2.1/config/</STRONG>. Check the value of
the sys.path variable (see below) for hints, or ask your local Python
administrator. Do the following, using the appropriate directory: 
</P>

<PRE>
    cp /usr/lib/python2.1/config/Makefile.pre.in .
</PRE>

<P>
Next, create the Makefile from the Setup.in file, and compile the module.
</P>

<PRE>
    cp Setup.in Setup
    make -f Makefile.pre.in boot
    make
</PRE>

<P>
This will create a shared-object file <STRONG>crng.so</STRONG> (at
least on the Unix systems it has been tested on). This file must be
copied or moved to a directory in the Python search path. To display
your search path, do the following:
</P>

<PRE>
    python -c "import sys; print sys.path"
</PRE>

<P>
A common location is the
<STRONG>/usr/lib/python2.1/site-packages</STRONG> directory, but this
may require administrator privileges. Do the following, using the
appropriate directory:
</P>

<PRE>
    cp crng.so /usr/lib/python2.1/site-packages
</PRE>

<P>
Also copy the <STRONG>crng_pickle.py</STRONG> script to the same directory.
</P>

<P>
You should now be able to run the example scripts that are part of the
distribution:
</P>

<PRE>
    python validate.py
    python profile.py
    python display.py
</PRE>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Usage">Usage</A></H2>

<P>
All RNGs in the <STRONG>crng</STRONG> module are used in basically the
same way: 
<OL>
<LI> create an instance of the chosen RNG type, giving the
appropriate seeds and initialization parameters,
<LI> call that instance repeatedly to obtain new random numbers.
</OL>
</P>

<PRE>
    >>> import crng
    >>> r=crng.ParkMiller(seed=123)
    >>> r()
    0.000962643418909
    >>> r(2)
    (0.179147941609, 0.939454629989)
</PRE>

<P>
The initialization call at object creation is specific to each RNG
type, and is described in the sections for each RNG below.
</P>
<P>
The deviates of distributions other than the uniform (0,1)
distribution are generated by an appropriate mathematical
transformation of the values from a uniform (0,1)
distribution. Therefore, the non-standard deviate objects must all be
initialized with a basic RNG as argument. By default, ParkMiller is
used, but any basic RNG from the <STRONG>crng</STRONG> module may be
specified. 
</P>

<PRE>
    >>> n=crng.NormalDeviate(rng=crng.Ranlux(), stdev=4.0)
    >>> n(4)
    (0.960612428619, 6.30989834512, -0.972826635646, -2.09557141754)
</PRE>

<P>
All RNGs implement the same methods, except for the initialization
call. The members of the basic RNGs (if any) are usually
read-only. The members of the deviates other than the uniform (0,1)
distribution are usually read/write. 
</P>
<P>
A few utility functions for sampling and shuffling are provided,
which take as arguments a basic RNG and a sequence, i.e. a string,
tuple or list. The result is a new sequence of the same type as the
input. 
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Methods">Methods available for all RNG
objects</A></H2>

<P>
<TABLE WIDTH="100%" CELLPADDING=4 BORDER>

<TR BGCOLOR="AQUA">
<TH>Method call</TH>
<TH>Returned value</TH>
<TH>Comment</TH>
</TR>

<TR>
<TD>
<STRONG>r.next(n=1)</STRONG>
</TD>
<TD>
if <STRONG>n==1</STRONG>: single float
<BR>
if <STRONG>n&gt;1</STRONG>: tuple of floats
<BR>
where float <STRONG>0.0&lt;f&lt;1.0</STRONG>
</TD>
<TD>
The returned floating point value(s) are the next random number(s) in
the series.
</TD>
</TR>

<TR>
<TD>
<STRONG>r(n=1)</STRONG>
</TD>
<TD>
if <STRONG>n==1</STRONG>: single float
<BR>
if <STRONG>n&gt;1</STRONG>: tuple of floats
<BR>
where float <STRONG>0.0&lt;f&lt;1.0</STRONG>
</TD>
<TD>
Object instance call, which is equivalent to calling the method
<STRONG>next</STRONG>. 
</TD> 
</TR>

<TR>
<TD><STRONG>r.compute(n=1)</STRONG></TD>
<TD>None</TD>
<TD>
Compute the next <STRONG>n</STRONG> random number in the series, where
<STRONG>n</STRONG> is a positive integer, but do not return any
values. This may be useful for profiling the C implementation of the
RNG.
</TD>
</TR>

<TR>
<TD><STRONG>r.density(x)</STRONG></TD>
<TD>single float</TD>
<TD>
The density of the distribution function at <STRONG>x</STRONG>.
</TD>
</TR>

<TR>
<TD><STRONG>str(r)</STRONG></TD>
<TD>
string
<BR>
e.g. '&lt;crng.ParkMiller object at 0x80a6860&gt;'
</TD>
<TD>
The built-in <STRONG>str()</STRONG> function calls an internal
function defined for the object. It returns an informal string
representation of the RNG instance, which contains the type of the RNG 
and its memory address.
</TD>
</TR>

<TR>
<TD><STRONG>repr(r)</STRONG></TD>
<TD>
string
<BR>
e.g. 'crng.ParkMiller(seed=314159265)'
</TD>
<TD>
The built-in <STRONG>repr()</STRONG> function calls an internal
function defined for the object. It returns a string  representation
of the RNG instance that is a valid Python code string, which can be
used in an <STRONG>eval</STRONG> expression.
</TD>
</TR>

</TABLE>
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Saving">Saving and restoring an RNG
object</A></H2>

<P>
The current state of any instance of a <STRONG>crng</STRONG> type can
be retrieved through its members. This allows creation of an identical
copy of an instance. One may also save an instance and retrieve it at
a later stage without loss of information.
</P>
<P>
Basically, there are two independent ways to save and retrieve an
instance of an <STRONG>crng</STRONG> type.
</P>

<H3>repr and eval()</H3>

<P>
All RNG types (basic as well as non-standard deviates) define an
internal function called by the built-in function
<STRONG>repr</STRONG>, which produces a string representation of the
instance that is valid Python code. The string contains the module
name prepended to the type name. This can be used to create copies of
an RNG instance:
</P>

<PRE>
    >>> import crng
    >>> r1 = crng.ParkMiller(seed=123)
    >>> s = repr(r1)
    >>> print s
    crng.ParkMiller(seed=123)
    >>> r2 = eval(s)
    >>> print r1(), r2()
    0.000962643418461 0.000962643418461
</PRE>

<P>
Note that the string returned by the <STRONG>repr</STRONG>
function is quite long for the RNGs that contain large state vectors
(mainly <A HREF="#Ranlux">Ranlux</A> and
<A HREF="#MT19937">MT19937</A>). The non-standard deviates produce
strings that also contain a representation of the basic RNG they use.
</P>

<P>
In Python 1.5.2, the string created by <STRONG>repr</STRONG> for a
float value is sometimes not an exact representation of the
value. This problem carries over to the representation of the RNG
types. This has been fixed in Python 1.6 and later.
</P>

<H3>pickle/cPickle</H3>

<P>
The standard Python module <STRONG>pickle</STRONG> (and its optimized
C implementation <STRONG>cPickle</STRONG>) can be used to store an RNG
type in a safe manner. The script
<A HREF="#crng_pickle.py">crng_pickle.py</A> must be imported by a
script that does a save and/or retrieve operation; this script
performs the required setup as it is imported.
</P>
<P>
Here are two example scripts showing how to use
<STRONG>pickle/cPickle</STRONG> with the <STRONG>crng</STRONG>
types.

<P>
The first script saves an <STRONG>crng</STRONG> instance to a file
using <STRONG>pickle</STRONG>. Note that the script
<STRONG>crng_pickle</STRONG> must be imported by this script.
</P>

<PRE>
    import crng
    import crng_pickle
    import pickle

    rng = crng.Ranlux(luxury=4, seed=54987)
    rng.compute(1000)

    file = open('rng.save', 'w')
    pickler = pickle.Pickler(file)
    pickler.dump(rng)
    rng.compute(10)
    print rng(2)                    # (0.77230155468, 0.246806561947)
</PRE>

<P>
The second script retrieves the stored <STRONG>crng</STRONG> instance
from the file using <STRONG>pickle</STRONG>. Note that this script
does not need to import neither the <STRONG>crng_pickle</STRONG> nor
the <STRONG>crng</STRONG> modules.
</P>

<PRE>
    import pickle

    file=open('rng.save')
    unpickler = pickle.Unpickler(file)
    rng = unpickler.load()
    rng.compute(10)
    print rng(2)                    # (0.77230155468, 0.246806561947)
</PRE>

<P>

</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="C interface">C interface</A></H2>

<P>
The <STRONG>crng</STRONG> module provides an interface to allow other
Python extension modules written in C to access the C implementation
of the RNGs directly. Notice that the interface is not designed to
allow any C code to access the <STRONG>crng</STRONG> functions, but
only to provide access via Python objects to the <STRONG>crng</STRONG>
implementation for Python extension modules written in C.
</P>
<P>
The interface consists of a CObject containing a pointer to the C
function for producing the next value for the RNG. The CObject is a 
private member of the <STRONG>crng</STRONG> instance. It is not
visible in the <STRONG>__members__</STRONG> attribute of the
instance. In order to use it, the application Python code must provide
the <STRONG>crng</STRONG> instance as an  argument to the client
Python function (a Python extension coded in C). The C implementation
of the client function fetches the CObject from the instance, and gets
the C pointer to the RNG function, which can then be used in the C
code. 
</P>
<P>
An example shows how the Python application code creates a
<STRONG>crng</STRONG> instance, which is passed to the client Python
extension, in this case a Monte Carlo integrator:
</P>

<PRE>
  import crng
  import MonteCarloIntegrator
  rng = crng.MT19973(seed=123)
  mci = MonteCarloIntegrator(func=function_to_integrate, rng=rng)
  integral = mci.integrate(region=(0,1))
</PRE>

<P>
And here are the relevant parts of the C code for the object
initialization function in the Python extension module
MonteCarloIntegrator:
</P>

<PRE>
  static PyObject *
  MonteCarloIntegrator_new (PyObject *self, PyObject *args)
  {
    PyObject *func, *rng, *cobj;
    double (*rng_next_value) (PyObject *rng);
    double rng_value;

    if (! PyArg_ParseTuple(args, "OO", &(func), &(rng)))
      goto error;

    /* ... code removed for clarity */

    cobj = PyObject_GetAttrString(rng, "_crng_basic_next_value");
    if (cobj && PyCObject_Check(cobj)) {
      rng_next_value = (double (*)(PyObject *)) PyCObject_AsVoidPtr(cobj);
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "rng must be a basic RNG from module crng");
      goto error;
    }

    /* ... code removed for clarity */

    rng_value = rng_next_value(rng);

    /* ... code removed for clarity */

  }
</PRE>

<P>
The C function prototypes and return values are the same for the basic
RNGs, but may be different for the non-basic deviate RNGs, depending
on the type of the deviate. The CObject member name and the
declaration for the C function pointer it contains are given for each
RNG below. Note that the same CObject member name may return pointers
to a C function with different prototypes depending on the RNG.
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Scripts">Scripts</A></H2>

A few Python scripts are included in the distribution.

<H3><A NAME="validate.py">validate.py</A></H3>

<P>
The script <A HREF="validate.py">validate.py</A> tests whether the
<STRONG>crng</STRONG> implementation of a few specific RNGs produces
values that agree with values given in the original reference for the
RNG. Thus, the tests validate both the portability and the current
implementation of the RNGs. 
</P>

<P>
Currently, the following RNGs are validated by the script: ParkMiller,
WichmannHill, Ranlux and MT19937.
</P>

<H3><A NAME="profile.py">profile.py</A></H3>

<P>
The script <A HREF="profile.py">profile.py</A> contains code to
perform profiling (CPU timing) measurements for the RNGs. The results
for two different systems are given in
<A HREF="#Profiling">the profiling table</A>.
</P>

<H3><A NAME="display.py">display.py</A></H3>

<P>
The script <A HREF="display.py">display.py</A> uses the Tkinter module
to display some non-standard distributions. Using the radiobuttons in
the menu, it is possible to change the distribution for one or both
axes of the coordinate system. For each change, a new set of random
values are generated and the corresponding points are displayed.
</P>

<H3><A NAME="crng_pickle.py">crng_pickle.py</A></H3>

<P>
The script <A HREF="crng_pickle.py">crng_pickle.py</A> performs the
setup required to use the standard Python
<STRONG>pickle/cPickle</STRONG> modules with <STRONG>crng</STRONG>
instances. It uses the standard Python <STRONG>copy_reg</STRONG>
module to do this.
</P>
<P>
This script should be installed in the same location as the
<STRONG>crng</STRONG> module compiled shared-object file
<STRONG>crng.so</STRONG>. This script needs only to be imported; no
other actions are required to perform the setup. See the section 
<A HREF="#Saving">Saving and restoring an RNG object</A> for
information on how to use it.
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Profiling">Profiling (CPU timings)</A></H2>

<P>
The CPU execution times were measured by running the
<STRONG>compute</STRONG> function of each RNG for at least 5 million
iterations. This measures the speed of the C implementation, with
minimal overhead for the Python system. When using the
<STRONG>next</STRONG> function in Python code, the execution speed
will be significantly slower due to the overhead of the Python
system. 
</P>
<P>
The script <A HREF="#profile.py">profile.py</A> contains code to
perform profiling measurements. 
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>

<TR>
<TH ROWSPAN="2">
RNG
</TH>
<TH COLSPAN="2">
Pentium III 500 MHz, Linux Red Hat 6.1, gcc (2.91.66) -g -O2 
</TH>
<TH COLSPAN="2">
SGI O2 (MIPS R5200), IRIX 6.5, cc MIPSpro 7.30 -O -n32
</TH>
</TR>

<TR>
<TH>10<SUP>6</SUP> iterations per second</TH>
<TH>microseconds per iteration</TH>
<TH>10<SUP>6</SUP> iterations per second</TH>
<TH>microseconds per iteration</TH>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#ParkMiller">ParkMiller()</A></TD>
<TD>5.5</TD>
<TD>0.18</TD>
<TD>4.8</TD>
<TD>0.21</TD>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#WichmannHill">WichmannHill()</A></TD>
<TD>1.7</TD>
<TD>0.59</TD>
<TD>1.0</TD>
<TD>0.96</TD>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#LEcuyer">LEcuyer()</A></TD>
<TD>4.0</TD>
<TD>0.25</TD>
<TD>3.3</TD>
<TD>0.30</TD>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#Ranlux">Ranlux(luxury=0)</A></TD>
<TD>7.4</TD>
<TD>0.14</TD>
<TD>6.0</TD>
<TD>0.17</TD>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#Ranlux">Ranlux(luxury=1)</A></TD>
<TD>5.1</TD>
<TD>0.20</TD>
<TD>3.7</TD>
<TD>0.27</TD>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#Ranlux">Ranlux(luxury=2)</A></TD>
<TD>3.1</TD>
<TD>0.32</TD>
<TD>2.2</TD>
<TD>0.45</TD>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#Ranlux">Ranlux(luxury=3)</A></TD>
<TD>1.5</TD>
<TD>0.65</TD>
<TD>1.1</TD>
<TD>0.94</TD>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#Ranlux">Ranlux(luxury=4)</A></TD>
<TD>0.93</TD>
<TD>1.1</TD>
<TD>0.63</TD>
<TD>1.6</TD>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#Taus88">Taus88()</A></TD>
<TD>9.8</TD>
<TD>0.10</TD>
<TD>6.4</TD>
<TD>0.16</TD>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#MRG32k3a">MRG32k3a()</A></TD>
<TD>1.7</TD>
<TD>0.59</TD>
<TD>2.0</TD>
<TD>0.51</TD>
</TR>

<TR ALIGN="CENTER">
<TD><A HREF="#MT19937">MT19937()</A></TD>
<TD>6.0</TD>
<TD>0.17</TD>
<TD>5.0</TD>
<TD>0.20</TD>
</TR>

<TR ALIGN="CENTER">
<TD>rand<BR>(C stdlib; not in crng)</TD>
<TD>6.1</TD>
<TD>0.16</TD>
<TD>4.4</TD>
<TD>0.23</TD>
</TR>

<TR ALIGN="CENTER">
<TD>whrandom.py<BR>(Python standard library)</TD>
<TD>0.065</TD>
<TD>15.43</TD>
<TD>-</TD>
<TD>-</TD>
</TR>

<!--
<TR ALIGN="CENTER">
<TD></TD>
<TD></TD>
<TD></TD>
<TD></TD>
<TD></TD>
</TR>
-->

</TABLE>
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Changes 1.2">Changes in version 1.2</A></H2>

<P>
The changes in version 1.2 are only fixes for bugs. No new features
have been implemented.
</P>

<UL>
<LI>
Memory leaks in the <A HREF="#Sampling">sampling and shuffling</A>
functions were discovered by Ross Lazarus. These have now been
fixed. None of the fixes should affect any calculated result.
</UL>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Changes 1.1">Changes in version 1.1</A></H2>

<P>
The changes in version 1.1 are fairly minor. Nothing has changed in
the basic functionality and interface, nor are there any new RNG
implementations.
</P>

<UL>
<LI>
The script (or module) <A HREF="#crng_pickle.py">crng_pickle.py</A>
has been added, which sets things up for using the
<STRONG>crng</STRONG> module with the <STRONG>pickle/cPickle</STRONG>
modules. 
<LI>
A new utility function <STRONG><A HREF="#stir">stir</A></STRONG> has
been added; it shuffles a list in-place.
<LI>
The types
<STRONG><A HREF="#Ranlux">Ranlux</A></STRONG> and 
<STRONG><A HREF="#MT19937">MT19937</A></STRONG> now have an optional 
initialization argument <STRONG>state</STRONG> and the corresponding
attribute, which allows save/retrieve operations.
<LI>
The intervals of allowed seed values for
<STRONG><A HREF="#WichmannHill">WichmannHill</A></STRONG> have been
increased to the true intervals to allow save/retrieve operations. 
<LI>
The <STRONG>repr</STRONG> function has been implemented for all RNG
types, and now yields a string that can be used with
<STRONG>eval</STRONG> to create a copy of the instance. The module 
identifier is prefixed to the type identifier.
<LI>
The <STRONG>repr</STRONG> functions for
<STRONG><A HREF="#MRG32k3a">MRG32k3a</A></STRONG> and
<STRONG><A HREF="#Taus88">Taus88</A></STRONG> have been
fixed. Previously, they did not output the unsigned long values
correctly. 
<LI>
The <STRONG>str</STRONG> function now outputs only the type identifier
and the memory address; no attribute values are included. 
<LI>
The identifiers for the utility functions
<STRONG><A HREF="#sample">sample</A></STRONG>,
<STRONG><A HREF="#choose">choose</A></STRONG>,
<STRONG><A HREF="#shuffle">shuffle</A></STRONG> and
<STRONG><A HREF="#pick">pick</A></STRONG> have been
changed to all lower-case. The old capitalized identifiers (Sample,
Choose, Shuffle, Pick) are still available as aliases, but are
deprecated, and will be removed in a future version.
<LI>
A script <A HREF="#setup.py">setup.py</A> has been added for
installation using the Distutils tools.
<LI>
Instances of the non-standard deviate types now raise a
<STRONG>TypeError</STRONG> when an assignment to a non-existent
attribute is attempted. Previously, such attempts were just silently
ignored. 
<LI>
Fixed the NormalDeviate type C record and next_value calculation to
make changing mean and stdev safe when a raw random value has been
stored since the previous calculation (the Box-Muller method).
<LI>
Some minor internal changes in the C source code to allow direct
compilation using various Windows compilers (MS Visual C++ and Borland
C).
<LI>
A minor internal change in the Ranlux implementation to remove the
nskip variable from the type C record.
</UL>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="To do">To do</A></H2>

<P>
<UL>
<LI>
Implement additional distributions: Cauchy (Lorentz),
hypergeometric, bivariate Gaussian,  spherical?
<LI>
Implement some statistical tests; Knuth, Marsaglia's DIEHARD...
</UL>
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="References">References</A></H2>

<P>
M. Galassi, J. Davies, J. Theiler, B. Gough, R. Priedhorsky,
G. Jungman, M. Booth, "GNU Scientific Library 0.5" (1999). 
<A HREF="http://sources.redhat.com/gsl/">http://sources.redhat.com/gsl/</A>.
</P>
<P>
J.E. Gentle (1998), "Random Number Generation and Monte Carlo
Methods", Springer, ISBN 0-387-98522-0.
</P>
<P>
D.E. Knuth (1998), "The Art of Computer Programming", Vol. 2,
"Seminumerical Algorithms", 3rd edition, Addison-Wesley, ISBN
0-201-89684-2. Chapter 3: Random numbers.
</P>
<P>
W.H. Press, S.A. Teukolsky, W.T. Vetterling and B.P. Flannery (1992)
"Numerical Recipes in C", 2nd edition, Cambridge University Press,
ISBN 0-521-43108-5. Chapter 7: Random numbers.
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Acknowledgments">Acknowledgments</A></H2>

<P>
Many thanks for miscellaneous contributions to this module since its
first release: Alex Martelli, Paul Moore, Tim Peters, Anton
Vredegoor. 
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Basic">Basic RNGs: uniform (0,1)
distribution</A></H2>

<P>
All basic RNGs implemented in the <STRONG>crng</STRONG> module produce
values uniformly distributed in the open interval (0,1),
i.e. exclusive of the end-point values 0 and 1.
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING=4 BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="ParkMiller">ParkMiller</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = ParkMiller(seed=314159265)</STRONG>
<P>
<STRONG>seed</STRONG>: initial seed, positive integer
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read-only.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_basic_next_value</STRONG> or
<STRONG>_crng_next_value</STRONG> 
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Period</TD>
<TD>2.1*10<SUP>9</SUP></TD>
</TR>
<TR>
<TD>Reference</TD>
<TD>
Stephen K. Park and Keith W. Miller, Communication of the ACM (1988)
31, 1192-1201. "Random Number Generators: Good Ones Are Hard to
Find."
</TD>
<TR>
<TD>Comment</TD>
<TD>
This is the 'minimal standard' RNG proposed by the authors in the
reference. The implementation is a translation of the Pascal code
given as "Integer Version 2" in the reference.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING=4 BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="WichmannHill">WichmannHill</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<P>
<STRONG>r = WichmannHill(seed1=314, seed2=159, seed3=365)</STRONG>
</P>
<P>
<STRONG>seed1</STRONG>: initial first seed, integer such that
<STRONG>0&lt;seed&lt;=30268</STRONG> 
</P>
<P>
<STRONG>seed2</STRONG>: initial second seed, integer such that
<STRONG>0&lt;seed&lt;=30306</STRONG> 
</P>
<P>
<STRONG>seed3</STRONG>: initial third seeds integer such that
<STRONG>0&lt;seed&lt;=30322</STRONG>
</P>
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read-only.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_basic_next_value</STRONG> or
<STRONG>_crng_next_value</STRONG> 
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Period</TD>
<TD>6.95*10<SUP>12</SUP></TD>
</TR>
<TR>
<TD>References</TD>
<TD>
B.A. Wichmann and I.D. Hill, Applied Statistics (1982) 31,
188-190. "Algorithm AS 183. An Efficient and Portable
Pseudo-random Number Generator."
<P>
B.A. Wichmann and I.D. Hill, Applied Statistics (1984) 33,
123. "Correction: Algorithm AS 183"
</TD>
</TR>
<TR>
<TD>See also</TD>
<TD>
A. Ian McLeod, Applied Statistics (1985) 34, 198-200. "A Remark
on Algorithm AS 183."
<P>
The standard Python module <STRONG>whrandom.py</STRONG>.
</TD>
</TR>
<TR>
<TD>Comment</TD>
<TD>
The McLeod paper points out that the algorithm may produce some zero
values due to rounding errors under certain circumstances when 32 bit
precision is used. The proposed amendment to fix this problem has
<STRONG>not</STRONG> been implemented, since the computations in this
implementation are done in double precision.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING=4 BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="LEcuyer">LEcuyer</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = LEcuyer(seed1=314159265, seed2=314159263)</STRONG>
<P>
<STRONG>seed1, seed2</STRONG>: initial seeds, positive integers
</TD>
</TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read-only.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_basic_next_value</STRONG> or
<STRONG>_crng_next_value</STRONG> 
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Period</TD>
<TD>2.3*10<SUP>18</SUP></TD>
</TR>
<TR>
<TR>
<TD>Reference</TD>
<TD>
Pierre L'Ecuyer, Communications of the ACM (1988) 31,
742-749+774. "Efficient and Portable Combined Random Number
Generators."
</TD>
</TR>
<TR>
<TD>Web site</TD>
<TD><A HREF="http://www.iro.umontreal.ca/~lecuyer/">
http://www.iro.umontreal.ca/~lecuyer/</A></TD>
</TR>
<TR>
<TD>Comment</TD>
<TD>
This is a combination of two Multiplicative Congruential Generators
(MLCGs). The implementation is a translation of the code from fig. 3
of the reference.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING=4 BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="Ranlux">Ranlux</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<P>
<STRONG>r = Ranlux(luxury=3, seed=314159265, state=None)</STRONG>
</P>
<P>
<STRONG>luxury</STRONG>: the quality level, integer such that:
<BR>
0: Equivalent to original RCARRY by Marsaglia and Zaman. Has a very
long period, but fails many tests.
<BR>
1: Considerable improvement in quality over level 0. Passes the gap
test, but still fails the spectral test.
<BR>
2: Passes all known tests, but theoretically still defective.
<BR>
3: Any theoretically possible correlations have a very small chance
of being observed.
<BR>
4: Highest possible luxury, all 24 bits chaotic.
</P>
<P>
<STRONG>seed</STRONG>: initial seed, positive integer
</P>
<P>
<STRONG>state</STRONG>: set the initial state from a state tuple
(available as a member in another Ranlux instance). This argument, if
given, overrides the luxury and seed arguments.
<STRONG>Warning</STRONG>: only values obtained from the state member
in another Ranlux instance should be used; attempts to use a state 
tuple built from scratch may result in a dangerously invalid
instance.
</P>
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
<P>
<STRONG>luxury</STRONG>: the quality level; read-only
</P>
<P>
<STRONG>state</STRONG>: the tuple reflecting the current state; read-only
</P>
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_basic_next_value</STRONG> or
<STRONG>_crng_next_value</STRONG> 
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Period</TD>
<TD>approximately 5.2*10<SUP>171</SUP></TD>
</TR>
<TR>
<TD>References</TD>
<TD>
Martin L&uuml;scher, Computer Physics Communications (1994) 79,
100-110. "A portable high-quality random number generator for
lattice field theory simulations."
<P>
F. James, Computer Physics Communications (1994) 79,
111-114. "RANLUX: A Fortran implementation of the high-quality
pseudorandom number generator of L&uuml;scher."
<P>
F. James, Computer Physics Communications (1996) 97,
357. "Erratum. RANLUX: A Fortran implementation of the
high-quality pseudorandom number generator of L&uuml;scher."
</TD>
<TR>
<TD>See also</TD>
<TD>
Kenneth G. Hamilton and F. James, Computer Physics Comunications
(1997) 101, 241-248. "Acceleration of RANLUX."
</TD>
</TR>
<TR>
<TD>Comment</TD>
<TD>
The implementation is based on the Fortran 77 version written by Fred
James, as posted to a Usenet News group on 16 March 1995 by Byron Bodo.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING=4 BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="Taus88">Taus88</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = Taus88(seed1=314159265, seed2=314159263,
seed3=314159261)</STRONG>
<P>
<STRONG>seed1</STRONG>: first initial seed, integer &gt;=2
<BR>
<STRONG>seed2</STRONG>: second initial seed, integer &gt;=8
<BR>
<STRONG>seed3</STRONG>: third initial seed, integer &gt;=16
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read-only.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_basic_next_value</STRONG> or
<STRONG>_crng_next_value</STRONG> 
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Period</TD>
<TD>Approximately 2<SUP>88</SUP> = 3.1*10<SUP>26</SUP></TD>
</TR>
<TR>
<TD>Reference</TD>
<TD>
Pierre L'Ecuyer, Mathematics of Computation (1996) 65,
203-213. "Maximally equidistributed combined Tausworthe
generators."
</TD>
</TR>
<TR>
<TD>Web site</TD>
<TD><A HREF="http://www.iro.umontreal.ca/~lecuyer/">
http://www.iro.umontreal.ca/~lecuyer/</A></TD>
</TR>
<TR>
<TD>Comment</TD>
<TD>
The implementation is from figure 1 of the reference.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING=4 BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="MRG32k3a">MRG32k3a</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = MRG32k3a(s10=314159265, s11=314159263, s12=314159261,
s20=314159259, s21=314159257, s22=314159255)</STRONG>
<P>
<STRONG>s10, s11, s12</STRONG>: initial seed vector s1 elements,
positive integers 
<BR>
<STRONG>s20, s21, s22</STRONG>: initial seed vector s2 elements,
positive integers 
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read-only.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_basic_next_value</STRONG> or
<STRONG>_crng_next_value</STRONG> 
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Period</TD>
<TD>Approximately 2<SUP>191</SUP> = 3.1*10<SUP>57</SUP></TD>
</TR>
<TR>
<TD>Reference</TD>
<TD>
Pierre L'Ecuyer, Operations Research (1999) 47, 159-164. "Good
parameters and implementations for combined multiple recursive random
number generators."
</TD>
</TR>
<TR>
<TD>Web site</TD>
<TD><A HREF="http://www.iro.umontreal.ca/~lecuyer/">
http://www.iro.umontreal.ca/~lecuyer/</A></TD>
</TR>
<TR>
<TD>Comment</TD>
<TD>
The implementation is from figure 1 of the reference.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING=4 BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="MT19937">MT19937</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<P>
<STRONG>r = MT19937(seed=314159265, state=None)</STRONG>
</P>
<P>
<STRONG>seed</STRONG>: initial seed, positive integer
</P>
<P>
<STRONG>state</STRONG>: set the initial state from a state tuple
(available as a member in another MT19937 instance). This argument, if
given, overrides the seed argument. <STRONG>Warning</STRONG>: only
values obtained from the state member in another MT19937 instance
should be used; attempts to use a state tuple built from scratch may
result in a dangerously invalid instance.
</P>
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
<P>
<STRONG>state</STRONG>: the tuple reflecting the current state; read-only
</P>
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_basic_next_value</STRONG> or
<STRONG>_crng_next_value</STRONG>
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Period</TD>
<TD>2<SUP>19937</SUP>-1 = approximately 4.3*10<SUP>6001</SUP></TD>
</TR>
<TR>
<TD>Reference</TD>
<TD>
Makoto Matsumoto and Takuji Nishimura, ACM Transactions on Modeling
and Computer Simulation (1998) 8, 3-30. "Mersenne Twister: A
623-dimensionally equidistributed uniform pseudorandom number
generator."
</TD>
</TR>
<TR>
<TD>Web site</TD>
<TD><A HREF="http://www.math.keio.ac.jp/matumoto/emt.html">
http://www.math.keio.ac.jp/matumoto/emt.html</A></TD>
</TR>
<TR>
<TD>Comment</TD>
<TD>
The implementation uses the C code available at the web site (above),
which is copyrighted by Matsumoto and Nishimura, and has been released
by them under the GNU Lesser General Public License (LGPL).
</TD>
</TR>
<TR>
<TD>Copyright</TD>
<TD>
Copyright &copy; 1997, 1999 Makoto Matsumoto and Takuji Nishimura.
<P>
When you use this, send an email to: matumoto@math.keio.ac.jp
with an appropriate reference to your work.
<P>
The MT19937 code by Matsumoto and Nishimura is distributed under the
GNU Lesser General Public License (formerly known as Library General
Public License) as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.
<P>
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.
<P>
You should have received a copy of the GNU Lesser General
Public License along with this library (file
<A HREF="lgpl.txt">lgpl.txt</A>); if not, write to the Free
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA. 
</TD>
</TR>
</TABLE>
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="continuous">Deviates of continuous
distributions</A></H2> 

<P>
The deviates of the continuous distributions other than the uniform
(0,1) distribution are computed by an appropriate mathematical
transformation of values taken from the uniform (0,1)
distribution. The extension types for the deviates have been designed 
so that any basic RNG from the <STRONG>crng</STRONG> module can be
used. The choice is made at initialization, but may be changed after
creation. Note that only basic RNGs are valid in this context; e.g. a
GammaDeviate object cannot be used as a RNG for another GammaDeviate.
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="UniformDeviate">UniformDeviate</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = UniformDeviate(rng=ParkMiller(), a=0.0, b=1.0)</STRONG> 
<P>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
<BR>
<STRONG>a, b</STRONG>: the limits of the open interval, such that
<STRONG>a&lt;b</STRONG> 
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read/write.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_next_value</STRONG>
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="ExponentialDeviate">ExponentialDeviate</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = ExponentialDeviate(rng=ParkMiller(), mean=1.0)</STRONG> 
<P>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
<BR>
<STRONG>mean</STRONG>: the deviate mean value, must be positive
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read/write.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_next_value</STRONG>
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
For a radioactive substance with a long half-life, the time between 
successive decay events is drawn from an exponential
distribution. Similarly, the waiting times between the arrival of
customers to an office can be described by an exponential
distribution, provided the average influx is constant. Or, for a set
of radioactive nuclei at time 0, the decay events occur at the times
{X}, where {X} are exponential deviates. The half-life of the
exponential is related to the mean by
<STRONG>t<SUB>0.5</SUB>=mean*ln(2)</STRONG>. 
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="NormalDeviate">NormalDeviate</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = NormalDeviate(rng=ParkMiller(), mean=0.0, stdev=1.0,
stored=None)</STRONG> 
<P>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
<BR>
<STRONG>mean</STRONG>: the deviate mean value
<BR>
<STRONG>stdev</STRONG>: the deviate standard deviation, must be positive
<BR>
<STRONG>stored</STRONG>: next raw random value (if any); saved  from the
previous calculation
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
<P>
Same as in the initialization call; read/write, <STRONG>except</STRONG>:
</P>
<P>
<STRONG>stored</STRONG>: the next raw (mean and stdev have not been
applied) random value (if any), saved from the previous calculation
(every other call); read-only
</P>
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_next_value</STRONG>
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
Also called the Gaussian deviate; the density function is a Gaussian.
</TD>
</TR>
<TR>
<TD>References</TD>
<TD>
G.E.P. Box and M.E. Muller, Annals Math. Stat. (1958) 29, 610-611. "A
note on the generation of random normal deviates."
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="GammaDeviate">GammaDeviate</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = GammaDeviate(rng=ParkMiller(), order=2.0, scale=1.0,
direct=(order<=12))</STRONG>
<P>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
<BR>
<STRONG>order</STRONG>: the order of the gamma deviate, must be positive
<BR>
<STRONG>scale</STRONG>: the scale factor; must be positive
<BR>
<STRONG>direct</STRONG>: use the direct method (log of the sum of
exponential random values), else the rejection method; integer
interpreted as boolean 
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read/write.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_next_value</STRONG>
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
If an event is the product of two or more sub-events, each having an
exponential distribution, then that event has a gamma
distribution. The number of sub-events is the order of the gamma
distribution.
</TD>
</TR>
<TR>
<TD>
Reference
</TD>
<TD>
J.H. Ahrens, Ann. Inst. Stat. Math. (1962) 13, 231-237.
</TD>
</TR>
<TR>
<TD>Comment</TD>
<TD>
The optimal choice between the direct method and the rejection method
for calculating the deviate depends to some extent on the properties
of the compiler and the hardware. The default choice made in the
current implementation is based on profiling (CPU timings) on a
Pentium III 500 MHz system running Linux Red Hat 6.1, and on a SGI O2
(MIPS R5200) system running IRIX 6.5. Note that using a fractional
order value significantly decreases the computational efficiency of
the direct method.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="BetaDeviate">BetaDeviate</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = BetaDeviate(rng=ParkMiller(), a=1.0, b=1.0)</STRONG> 
<P>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
<BR>
<STRONG>a, b</STRONG>: the parameters, must be positive
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read/write.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_next_value</STRONG>
<BR>
C function pointer: <STRONG>double (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Comment</TD>
<TD>
The calculation uses two gamma deviates which in turn call the
specified basic RNG. The choice of using the direct method or the
rejection method for calculating the gamma deviates is made
automatically based on the values of the parameters a and b. 
</TD>
</TR>
</TABLE>
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="integer">Deviates of integer-valued distributions</A></H2>

<P>
The deviates of the integer-valued distributions are computed by an 
appropriate mathematical transformation of values taken from the
uniform (0,1) distribution. The extension types for the deviates have
been designed so that any basic RNG from the <STRONG>crng</STRONG>
module can be used. The choice is made at initialization, but may be
changed after creation. Note that only basic RNGs are valid in this
context; e.g. a PoissonDeviate object cannot be used as a RNG for
another PoissonDeviate.
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="PoissonDeviate">PoissonDeviate</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = PoissonDeviate(rng=ParkMiller(), mean=1.0,
direct=(mean<12.0))</STRONG>
<P>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
<BR>
<STRONG>mean</STRONG>: the deviate mean value, must be &gt;=0.0
<BR>
<STRONG>direct</STRONG>: use the direct method, else the rejection method;
integer interpreted as boolean
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read/write.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>,
except that the functions that normally produce floats return integers.
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_next_value</STRONG>
<BR>
C function pointer: <STRONG>long (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
For a radioactive substance with a long half-life, the number of
decay events in a given time span is drawn from a Poisson
distribution. Similarly, the number of customers arriving to an office
in a given time span can be described by a Poisson distribution,
provided the average influx is constant. 
</TD>
</TR>
<TR>
<TD>Comment</TD>
<TD>
The optimal choice between the direct method and the rejection method 
for calculating the deviate depends to some extent on the properties
of the compiler and the hardware. The default choice made in the
current implementation is based on profiling (CPU timings) on a
Pentium III 500 MHz system running Linux Red Hat 6.1, and on a SGI O2
(MIPS R5200) system running IRIX 6.5.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="BinomialDeviate">BinomialDeviate</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = BinomialDeviate(rng=ParkMiller(), p=0.5, n=2)</STRONG> 
<P>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
<BR>
<STRONG>p</STRONG>: the probability of the event, in the interval [0,1]
<BR>
<STRONG>n</STRONG>: the number of trials, positive integer
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read/write.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>,
except that the functions that normally produce floats return integers.
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_next_value</STRONG>
<BR>
C function pointer: <STRONG>long (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
If an event occurs with a given probability, and a given number of
trials are made, then the binomial distribution describes the number
of successful trials.
</TD>
</TR>
<TR>
<TD>Comment</TD>
<TD>
The algorithm implemented contains a tunable parameter, which affects
the computational efficiency. Currently, this parameter is hardwired,
and its value was chosen by empirical tests.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="GeometricDeviate">GeometricDeviate</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = GeometricDeviate(rng=ParkMiller(), p=0.5)</STRONG> 
<P>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
<BR>
<STRONG>p</STRONG>: the probability of the event, in the interval (0,1]
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read/write.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>,
except that the functions that normally produce floats return integers.
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_next_value</STRONG>
<BR>
C function pointer: <STRONG>long (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
The number of independent trials to yield a success, for a given
probability of the success of each trial.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="BernoulliDeviate">BernoulliDeviate</A></TH>
</TR>
<TR>
<TD>Initialization</TD>
<TD>
<STRONG>r = BernoulliDeviate(rng=ParkMiller(), p=0.5)</STRONG> 
<P>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
<BR>
<STRONG>p</STRONG>: the probability, in the interval [0,1]
</TD>
</TR>
<TR>
<TD>Members</TD>
<TD>
Same as in the initialization call; read/write.
</TD>
</TR>
<TR>
<TD>Methods</TD>
<TD>
<STRONG>(), next(), compute(), density(), str(), repr()</STRONG>
<BR>
See <A HREF="#Methods">Methods available for all RNG objects</A>,
except that the functions that normally produce floats return integers.
</TD>
</TR>
<TR>
<TD>C interface</TD>
<TD>
Member name: <STRONG>_crng_next_value</STRONG>
<BR>
C function pointer: <STRONG>long (*next_value) (PyObject *rng)</STRONG>
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
The repeated flipping of a coin produces a Bernoulli series for a
probability 0.5 if heads and tails is represented by 1 and 0,
respectively. 
</TD>
</TR>
</TABLE>
</P>

<HR WIDTH="60%">
<H2 ALIGN="CENTER"><A NAME="Sampling">Sampling and shuffling</A></H2>

<P>
The following are utility functions for sampling and shuffling of a
sequence object (string, tuple or list). For <STRONG>choose</STRONG>,
<STRONG>sample</STRONG> and <STRONG>shuffle</STRONG>, the result is a
sequence of the same type as the input sequence.
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="choose">choose</A></TH>
</TR>
<TR>
<TD>Usage</TD>
<TD>
<STRONG>newseq = choose(seq, n, rng)</STRONG>
<P>
<STRONG>newseq</STRONG>: a new sequence of the same type as <STRONG>seq</STRONG>
<BR>
<STRONG>seq</STRONG>: the sequence (string, tuple or list) from which to
choose
<BR>
<STRONG>n</STRONG>: the number of objects to choose, such that
<STRONG>0&lt;=n&lt;=len(seq)</STRONG>
<BR>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
The objects in the output sequence are chosen <STRONG>without
replacement</STRONG> from the input sequence. The relative order of
the objects in the output sequence is preserved.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="sample">sample</A></TH>
</TR>
<TR>
<TD>Usage</TD>
<TD>
<STRONG>newseq = sample(seq, n, rng)</STRONG>
<P>
<STRONG>newseq</STRONG>: a new sequence of the same type as <STRONG>seq</STRONG>
<BR>
<STRONG>seq</STRONG>: the sequence (string, tuple or list) from which to
sample with replacement
<BR>
<STRONG>n</STRONG>: the number of objects to sample, such that
<STRONG>0&lt;=n&lt;=len(seq)</STRONG>
<BR>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
The objects in the output sequence are chosen <STRONG>with
replacement</STRONG> from the input sequence. The output sequence may
contain multiple references to the same object. The relative order of
the objects in the output sequence is random.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="shuffle">shuffle</A></TH>
</TR>
<TR>
<TD>Usage</TD>
<TD>
<STRONG>newseq = shuffle(seq, rng)</STRONG>
<P>
<STRONG>newseq</STRONG>: a new sequence of the same type as <STRONG>seq</STRONG>
<BR>
<STRONG>seq</STRONG>: the sequence (string, tuple or list) to shuffle
<BR>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
The objects in the output sequence are the same as in the input
sequence, but in random order compared to the input sequence.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="stir">stir</A></TH>
</TR>
<TR>
<TD>Usage</TD>
<TD>
<STRONG>stir(list, rng)</STRONG>
<P>
<STRONG>list</STRONG>: the list to be shuffled
<BR>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
The list is shuffled in-place.
</TD>
</TR>
</TABLE>
</P>

<P>
<TABLE WIDTH="100%" CELLPADDING="4" BORDER>
<TR>
<TH COLSPAN="2" BGCOLOR="AQUA"><A NAME="pick">pick</A></TH>
</TR>
<TR>
<TD>Usage</TD>
<TD>
<STRONG>obj = pick(seq, rng)</STRONG>
<P>
<STRONG>obj</STRONG>: the object picked from <STRONG>seq</STRONG>
<BR>
<STRONG>seq</STRONG>: the sequence (string, tuple or list) from which to
pick one object
<BR>
<STRONG>rng</STRONG>: a basic RNG from the <STRONG>crng</STRONG> module
</TD>
</TR>
<TR>
<TD>Description</TD>
<TD>
One object is picked at random from the given sequence.
</TD>
</TR>
</TABLE>
</P>
</BODY>
</HTML>
